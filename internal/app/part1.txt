package app

import (
	"fmt"
	"os"
	"sync"
	"time"

	"tit/internal/config"
	"tit/internal/git"
	"tit/internal/ui"

	tea "github.com/charmbracelet/bubbletea"
)

// Use ui.FileHistoryState and ui.FileHistoryPane (no duplication)

// Application is the central state container for the TIT (Terminal Interface for Time Travel) application.
// It manages all application state, UI rendering, git operations, and user interactions.
//
// The Application follows a strict UI THREAD / WORKER THREAD separation pattern:
// - UI THREAD: Handles rendering, input, and immediate user feedback
// - WORKER THREAD: Executes async git operations and state updates
//
// Key Responsibilities:
// - Maintains current application mode and state
// - Manages git repository state and operations
// - Handles user input and menu navigation
// - Coordinates async operations and UI updates
// - Enforces application invariants and contracts

type Application struct {
	width             int
	height            int
	sizing            ui.DynamicSizing
	theme             ui.Theme
	mode              AppMode // Current application mode
	quitConfirmActive bool
	quitConfirmTime   time.Time
	footerHint        string // Footer hint/message text
	gitState          *git.State
	selectedIndex     int                               // Current menu item selection
	menuItems         []MenuItem                        // Cached menu items
	keyHandlers       map[AppMode]map[string]KeyHandler // Cached key handlers

	// Input mode state
	inputState InputState // All input fields consolidated (Phase 5)

	// Clone workflow state
	cloneURL      string   // URL to clone from
	clonePath     string   // Path to clone into (cwd or subdir)
	cloneMode     string   // "here" (init+remote+fetch) or "subdir" (git clone)
	cloneBranches []string // Available branches after clone

	// Remote operation state
	remoteBranchName string // Current branch name during remote operations

	// Async operation state
	asyncOperationActive  bool    // True while git operation (clone, init, etc) is running
	asyncOperationAborted bool    // True if user pressed ESC to abort during operation
	isExitAllowed         bool    // False during critical operations (pull merge) to prevent premature exit
	previousMode          AppMode // Mode before async operation started (for restoration on ESC)
	previousMenuIndex     int     // Menu selection before async (for restoration)

	// Rewind operation state
	pendingRewindCommit string // Commit hash for pending rewind operation

	// Console output state (for clone, init, etc)
	consoleState      ui.ConsoleOutState
	outputBuffer      *ui.OutputBuffer
	consoleAutoScroll bool

	// Confirmation dialog state
	confirmationDialog *ui.ConfirmationDialog
	confirmType        string
	confirmContext     map[string]string

	// Conflict resolution state
	conflictResolveState *ConflictResolveState

	// Dirty operation tracking
	dirtyOperationState *DirtyOperationState // nil when no dirty op in progress

	// State display info maps
	workingTreeInfo map[git.WorkingTree]StateInfo
	timelineInfo    map[git.Timeline]StateInfo
	operationInfo   map[git.Operation]StateInfo

	// History mode state
	historyState *ui.HistoryState

	// File(s) History mode state
	fileHistoryState *ui.FileHistoryState

	// Time Travel state
	timeTravelInfo             *git.TimeTravelInfo // Non-nil only when Operation = TimeTraveling
	restoreTimeTravelInitiated bool                // True once restoration has been started

	// Git Environment state (5th axis - checked before all other state)
	gitEnvironment   git.GitEnvironment // Ready, NeedsSetup, MissingGit, MissingSSH
	setupWizardStep  SetupWizardStep    // Current step in setup wizard
	setupWizardError string             // Error message to display in SetupStepError
	setupEmail       string             // Email for SSH key generation
	setupKeyCopied   bool               // True once public key copied to clipboard

	// Cache fields (Phase 2)
	historyMetadataCache  map[string]*git.CommitDetails // hash â†’ commit metadata
	fileHistoryDiffCache  map[string]string             // hash:path:version â†’ diff content
	fileHistoryFilesCache map[string][]git.FileInfo     // hash â†’ file list

	// Cache status flags (CONTRACT: MANDATORY precomputation, no on-the-fly)
	cacheLoadingStarted bool // Guard against re-preloading
	cacheMetadata       bool // true when history metadata cache populated
	cacheDiffs          bool // true when file(s) history diffs cache populated

	// Cache progress tracking (for UI feedback during build)
	cacheMetadataProgress int // Current commit processed for metadata
	cacheMetadataTotal    int // Total commits to process
	cacheDiffsProgress    int // Current commit processed for diffs
	cacheDiffsTotal       int // Total commits to process
	cacheAnimationFrame   int // Animation frame for loading spinner

	// Mutexes for thread-safe cache access
	historyCacheMutex     sync.Mutex
	fileHistoryCacheMutex sync.Mutex
	diffCacheMutex        sync.Mutex

	// Config state (Session 86)
	appConfig       *config.Config // Loaded from ~/.config/tit/config.toml
	configMenuItems []MenuItem     // Uses menuItems + selectedIndex (no separate state needed)

	// Branch picker state (Session 86)
	branchPickerState *ui.BranchPickerState

	// Preferences state (Session 86)
	preferencesMenuItems []MenuItem // Preferences menu items (SSOT: GeneratePreferencesMenu)

	// Menu activity tracking (Session 2 - Lazy auto-update)
	lastMenuActivity    time.Time     // Track last menu navigation
	menuActivityTimeout time.Duration // Default: 5 seconds

	// Auto-update spinner state (Session 2)
	autoUpdateInProgress bool // True when auto-update is running
	autoUpdateFrame      int  // Animation frame for spinner
}

// ModeTransition configuration for streamlined mode changes
type ModeTransition struct {
	Mode        AppMode
	InputPrompt string
	InputAction string
	FooterHint  string
	InputHeight int
	ResetFields []string
}

// transitionTo handles standardized mode transitions and state resets.
func (a *Application) transitionTo(config ModeTransition) {
	a.mode = config.Mode

	// Always reset common input state
	a.selectedIndex = 0
	a.inputState.Reset()
	a.inputState.ClearConfirming = false

	// Set new input config from the transition configuration
	if config.InputPrompt != "" {
		a.inputState.Prompt = config.InputPrompt
	}
	if config.InputAction != "" {
		a.inputState.Action = config.InputAction
	}
	if config.FooterHint != "" {
		a.footerHint = config.FooterHint
	}
	if config.InputHeight > 0 {
		a.inputState.Height = config.InputHeight
	} else if config.Mode == ModeInput || config.Mode == ModeCloneURL {
		// Default to single-line input (4 = label + 3-line box)
		a.inputState.Height = 4
	}

	// Reset workflow-specific fields based on the configuration
	for _, field := range config.ResetFields {
		switch field {
		case "clone":
			a.cloneURL = ""
			a.clonePath = ""
			a.cloneBranches = nil
		case "all":
			// Reset all workflow states
			a.cloneURL = ""
			a.clonePath = ""
			a.cloneBranches = nil
		}
	}
}

// reloadGitState refreshes git state from repository.
// This is SSOT for all git state reloads in the application.
func (a *Application) reloadGitState() error {
	state, err := git.DetectState()
	if err != nil {
		return err
	}
	a.gitState = state
	return nil
}

// checkForConflicts detects if git is in conflicted state after an operation.
// Returns GitOperationMsg if conflicts detected, nil otherwise.
// successFlag: set to true when caller wants to trigger conflict resolver (e.g., dirty pull merge)
// successFlag: set to false for normal conflict detection during operations
func (a *Application) checkForConflicts(step string, successFlag bool) *GitOperationMsg {
	if err := a.reloadGitState(); err != nil {
		return nil
	}
	if a.gitState.Operation == git.Conflicted {
		return &GitOperationMsg{
			Step:             step,
			Success:          successFlag,
			ConflictDetected: true,
			Error:            "Merge conflicts detected",
		}
	}
	return nil
}

// executeGitOp executes a git command and returns appropriate message.
// This is SSOT for git command execution with standard error handling.
func (a *Application) executeGitOp(step string, args ...string) tea.Cmd {
	return func() tea.Msg {
		result := git.ExecuteWithStreaming(args...)
		if !result.Success {
			return GitOperationMsg{
				Step:    step,
				Success: false,
				Error:   result.Stderr,
			}
		}
		return GitOperationMsg{
			Step:    step,
			Success: true,
		}
	}
}

// newSetupWizardApp creates a minimal Application for the setup wizard
// This bypasses all git state detection since git environment is not ready
func newSetupWizardApp(sizing ui.DynamicSizing, theme ui.Theme, gitEnv git.GitEnvironment) *Application {
	app := &Application{
		sizing:          sizing,
		theme:           theme,
		mode:            ModeSetupWizard,
		gitEnvironment:  gitEnv,
		setupWizardStep: SetupStepWelcome,
		isExitAllowed:   true,
		consoleState:    ui.NewConsoleOutState(),
		outputBuffer:    ui.GetBuffer(),
	}
	app.keyHandlers = app.buildKeyHandlers()
	return app
}

// NewApplication creates a new application instance
func NewApplication(sizing ui.DynamicSizing, theme ui.Theme, cfg *config.Config) *Application {
	// PRIORITY 0: Check git environment BEFORE anything else
	// If git/ssh not available or SSH key missing, show setup wizard
	gitEnv := git.DetectGitEnvironment()
	InitGitLogger()
	if gitEnv != git.Ready {
		return newSetupWizardApp(sizing, theme, gitEnv)
	}

	// Try to find and cd into git repository
	isRepo, repoPath := git.IsInitializedRepo()
	if !isRepo {
		// Check parent directories
		isRepo, repoPath = git.HasParentRepo()
	}

	var gitState *git.State
	if isRepo && repoPath != "" {
		// Found a repo, cd into it and detect state
		if err := os.Chdir(repoPath); err != nil {
			// cannot cd into repo - this is a fatal error
			panic(fmt.Sprintf("cannot cd into repository at %s: %v", repoPath, err))
		}
		state, err := git.DetectState()
		if err != nil {
			// In a repo but state detection failed - this should not happen
			panic(fmt.Sprintf("Failed to detect git state in repo %s: %v", repoPath, err))
		}
		gitState = state
	} else {
		// Not in a repo - use NotRepo operation state to show init/clone menu
		gitState = &git.State{
			Operation: git.NotRepo,
		}
	}

	// CRITICAL: Check for incomplete time travel from previous session (Phase 0)
	// If TIT exited while time traveling, restore to original state
	if git.FileExists(".git/TIT_TIME_TRAVEL") && isRepo {
		// Will be handled after app creation to show status
		// (defer restoration until after UI is ready)
	}

	// Build state info maps
	workingTreeInfo, timelineInfo, operationInfo := BuildStateInfo(theme)

	app := &Application{
		sizing:                sizing,
		theme:                 theme,
		mode:                  ModeMenu,
		gitState:              gitState,
		selectedIndex:         0,
		asyncOperationActive:  false,
		asyncOperationAborted: false,
		isExitAllowed:         true, // Allow exit by default (disabled during critical operations)
		consoleState:          ui.NewConsoleOutState(),
		outputBuffer:          ui.GetBuffer(),
		consoleAutoScroll:     true, // Start with auto-scroll enabled
		workingTreeInfo:       workingTreeInfo,
		timelineInfo:          timelineInfo,
		operationInfo:         operationInfo,
		historyState: &ui.HistoryState{
			Commits:           make([]ui.CommitInfo, 0),
			SelectedIdx:       0,
			PaneFocused:       true, // Start with list pane focused
			DetailsLineCursor: 0,
			DetailsScrollOff:  0,
		},
		fileHistoryState: &ui.FileHistoryState{
			Commits:           make([]ui.CommitInfo, 0),
			Files:             make([]ui.FileInfo, 0),
			SelectedCommitIdx: 0,
			SelectedFileIdx:   0,
			FocusedPane:       ui.PaneCommits, // Start with commits pane focused
			CommitsScrollOff:  0,
			FilesScrollOff:    0,
			DiffScrollOff:     0,
			DiffLineCursor:    0,
			VisualModeActive:  false,
			VisualModeStart:   0,
		},
		// Initialize cache fields (Phase 2)
		historyMetadataCache:  make(map[string]*git.CommitDetails),
		fileHistoryDiffCache:  make(map[string]string),
		fileHistoryFilesCache: make(map[string][]git.FileInfo),
		cacheLoadingStarted:   false,
		cacheMetadata:         false,
		cacheDiffs:            false,

		// Config state (Session 86) - passed from main.go (fail-fast on load errors)
		appConfig:       cfg,
		configMenuItems: make([]MenuItem, 0),
		branchPickerState: &ui.BranchPickerState{
			Branches:          make([]ui.BranchInfo, 0),
			SelectedIdx:       0,
			PaneFocused:       true, // Start with list pane focused
			ListScrollOffset:  0,
			DetailsLineCursor: 0,
			DetailsScrollOff:  0,
		},
		preferencesMenuItems: make([]MenuItem, 0),
		// Menu activity tracking (Session 2 - Lazy auto-update)
		lastMenuActivity:    time.Now().Add(-10 * time.Second), // Start as inactive
		menuActivityTimeout: 5 * time.Second,
	}

	// Build and cache key handler registry once
	app.keyHandlers = app.buildKeyHandlers()

	// CRITICAL: Check for incomplete time travel restoration (Phase 0)
	// If TIT exited while time traveling, restore immediately
	// BUT: only if we're NOT currently in TimeTraveling state (which means we're actively traveling, not incomplete)
	hasTimeTravelMarker := git.FileExists(".git/TIT_TIME_TRAVEL") && isRepo
	shouldRestore := hasTimeTravelMarker && app.gitState.Operation != git.TimeTraveling

	// Load timeTravelInfo if actively time traveling
	// CRITICAL: If TimeTraveling but can't load info, that's CORRUPT STATE
	// Force restoration immediately to recover
	if app.gitState.Operation == git.TimeTraveling && hasTimeTravelMarker {
		ttInfo, err := git.LoadTimeTravelInfo()
		if err != nil {
			// CORRUPT STATE: TimeTraveling but can't load info
			// Force restoration to recover
			shouldRestore = true
		} else {
			app.timeTravelInfo = ttInfo
		}
	}

	if shouldRestore {
		// Show console and perform restoration
		app.mode = ModeConsole
		app.asyncOperationActive = true
		app.previousMode = ModeMenu
		app.footerHint = "Restoring from incomplete time travel session..."
	}

	// Pre-generate menu and load initial hint (for post-restoration)
	menu := app.GenerateMenu()
	app.menuItems = menu
	if len(menu) > 0 && !shouldRestore {
		// Only set hint if not restoring
		if app.gitState != nil && app.gitState.Remote == git.HasRemote && app.gitState.Timeline == "" && app.gitState.CurrentHash == "" {

		} else {
			app.footerHint = menu[0].Hint
		}
	}

	// Register menu shortcuts dynamically
	app.rebuildMenuShortcuts(ModeMenu)

	// Start pre-loading caches (CONTRACT: MANDATORY on startup)
	// Cache building will be triggered in Init() via tea.Cmd
	// Read-only operations, safe for any git state
	if !shouldRestore {
		app.cacheLoadingStarted = true
		// Cache build started in Init() method via tea.Batch
	}

	// If restoration needed, set up the async operation
	if shouldRestore {
		// Will be executed via Update() on first render
		app.asyncOperationActive = true
	}

	return app
}

// RestoreFromTimeTravel handles recovery from incomplete time travel sessions (Phase 0)
// Called if TIT detected .git/TIT_TIME_TRAVEL marker on startup
// Returns a tea.Cmd that performs the restoration and shows status
func (a *Application) RestoreFromTimeTravel() tea.Cmd {
	return func() tea.Msg {
		buffer := ui.GetBuffer()
		buffer.Clear()
		buffer.Append(ConsoleMessages["restoring_time_travel"], ui.TypeStatus)

		// Load time travel info
		ttInfo, err := git.LoadTimeTravelInfo()
		if err != nil {
			// Use standardized error logging (PATTERN: ErrorWarn for recovery paths)
			a.LogError(ErrorConfig{
				Level:      ErrorWarn,
				Message:    "Failed to load time travel info",
				InnerError: err,
				BufferLine: fmt.Sprintf(ErrorMessages["failed_load_time_travel_info"], err),
				FooterLine: "Failed to restore time travel state",
			})
			return RestoreTimeTravelMsg{
				Success: false,
				Error:   err.Error(),
			}
		}

		if ttInfo == nil {
			// Marker exists but no info - cleanup and continue
			git.ClearTimeTravelInfo()
			buffer.Append(ConsoleMessages["marker_corrupted"], ui.TypeStatus)
			return RestoreTimeTravelMsg{
				Success: true,
				Error:   "",
			}
		}

		// Step 1: Discard any changes made during time travel
		buffer.Append(ConsoleMessages["step_1_discarding"], ui.TypeStatus)
		// Use reset --hard instead of checkout . (works with uncommitted changes)
		resetResult := git.Execute("reset", "--hard", "HEAD")
		if !resetResult.Success {
			buffer.Append(ConsoleMessages["warning_discard_changes"], ui.TypeStatus)
		}

		cleanResult := git.Execute("clean", "-fd")
		if !cleanResult.Success {
			buffer.Append(ConsoleMessages["warning_remove_untracked"], ui.TypeStatus)
		}

		// Step 2: Return to original branch
		buffer.Append(fmt.Sprintf("Step 2: Returning to %s...", ttInfo.OriginalBranch), ui.TypeStatus)
		checkoutBranchResult := git.Execute("checkout", ttInfo.OriginalBranch)
		if !checkoutBranchResult.Success {
			buffer.Append(fmt.Sprintf("Error: Failed to checkout %s", ttInfo.OriginalBranch), ui.TypeStderr)
			return RestoreTimeTravelMsg{
				Success: false,
				Error:   "Failed to checkout original branch",
			}
		}

		// Step 3: Restore original stashed work if any
		if ttInfo.OriginalStashID != "" {
			buffer.Append(ConsoleMessages["step_3_restoring_work"], ui.TypeStatus)
			applyResult := git.Execute("stash", "apply", ttInfo.OriginalStashID)
			if !applyResult.Success {
				buffer.Append("Warning: Could not restore original work (may have been lost)", ui.TypeStatus)
			} else {
				buffer.Append(ConsoleMessages["original_work_restored"], ui.TypeStatus)
				dropResult := git.Execute("stash", "drop", ttInfo.OriginalStashID)
				if !dropResult.Success {
					buffer.Append(ConsoleMessages["warning_cleanup_stash"], ui.TypeStatus)
				}
			}
		}

		// Step 4: Clean up marker
		buffer.Append(ConsoleMessages["step_4_cleaning_marker"], ui.TypeStatus)
		err = git.ClearTimeTravelInfo()
		if err != nil {
			buffer.Append(fmt.Sprintf("Warning: Could not remove marker: %v", err), ui.TypeStatus)
		}

		buffer.Append(ConsoleMessages["restoration_complete"], ui.TypeStatus)

		return RestoreTimeTravelMsg{
			Success: true,
			Error:   "",
		}
	}
}

// handleRewind processes the result of a rewind (git reset --hard) operation
// Stays in console until user presses ESC
func (a *Application) handleRewind(msg RewindMsg) (tea.Model, tea.Cmd) {
	a.asyncOperationActive = false
	buffer := ui.GetBuffer()

	if !msg.Success {
		// Rewind failed - show error in console and stay
		buffer.Append(fmt.Sprintf(ErrorMessages["rewind_failed"], msg.Error), ui.TypeStderr)
		a.footerHint = GetFooterMessageText(MessageOperationFailed)
		return a, nil
	}

	// Rewind succeeded - show success message and stay in console
	buffer.Append(OutputMessages["rewind_completed"], ui.TypeStatus)
	a.footerHint = GetFooterMessageText(MessageOperationComplete)

	// Refresh git state for next menu display (when user presses ESC)
	a.reloadGitState() // silent failure is acceptable here

	return a, nil
}

// handleRestoreTimeTravel processes the result of time travel restoration (Phase 0)
func (a *Application) handleRestoreTimeTravel(msg RestoreTimeTravelMsg) (tea.Model, tea.Cmd) {
	a.asyncOperationActive = false
	a.restoreTimeTravelInitiated = false

	if !msg.Success {
		buffer := ui.GetBuffer()
		buffer.Append(fmt.Sprintf(ConsoleMessages["restoration_error"], msg.Error), ui.TypeStderr)
		a.footerHint = "Press ESC to acknowledge error"
		// Stay in console mode so user can read error
		return a, nil
	}

	// Reload git state after successful restoration
	if err := a.reloadGitState(); err != nil {
		buffer := ui.GetBuffer()
		buffer.Append(fmt.Sprintf(ConsoleMessages["error_detect_state"], err), ui.TypeStderr)
	}

	// Regenerate menu for new state
	menu := a.GenerateMenu()
	a.menuItems = menu
	a.selectedIndex = 0
	if len(menu) > 0 {
		a.footerHint = menu[0].Hint
	}

	// Stay in console mode until user presses ESC to acknowledge
	a.footerHint = "Restoration complete. Press ESC to continue"
	return a, nil
}

// Package-level counter for Update() calls
var updateCallCount int = 0

// Update handles all messages
func (a *Application) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	updateCallCount++
	// CRITICAL: If restoration is needed, initiate it on first update (Phase 0)
	hasMarker := git.FileExists(".git/TIT_TIME_TRAVEL")

	// Double-check before calling RestoreFromTimeTravel
	if a.asyncOperationActive && a.mode == ModeConsole && !a.restoreTimeTravelInitiated && hasMarker {
		// Verify marker still exists right before restoration
		a.restoreTimeTravelInitiated = true
		return a, a.RestoreFromTimeTravel()
	}

	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		a.width = msg.Width
		a.height = msg.Height
		a.sizing = ui.CalculateDynamicSizing(msg.Width, msg.Height)
		return a, nil

	case tea.KeyMsg:
		// Handle bracketed paste - entire paste comes as single KeyMsg with Paste=true
		if msg.Paste && a.isInputMode() {
			text := string(msg.Runes) // Don't trim - preserve formatting
			if len(text) > 0 {
				a.insertTextAtCursor(text)
				a.updateInputValidation()
			}
			return a, nil
		}
		keyStr := msg.String()

		// Handle ctrl+j (shift+enter equivalent) for newline in multiline input
		if a.isInputMode() && (keyStr == "ctrl+j" || keyStr == "shift+enter") {
			a.insertTextAtCursor("\n")
			return a, nil
		}

		// Look up handler in cached registry
		if modeHandlers, modeExists := a.keyHandlers[a.mode]; modeExists {
			if handler, exists := modeHandlers[keyStr]; exists {
				return handler(a)
			}
		}

		// Handle character input in input modes
		if a.isInputMode() && len(keyStr) == 1 && keyStr[0] >= 32 && keyStr[0] <= 126 {
			a.insertTextAtCursor(keyStr)
			a.updateInputValidation()
			return a, nil
		}

		// Handle backspace in input modes
		if a.isInputMode() && keyStr == "backspace" {
			a.deleteAtCursor()
			a.updateInputValidation()
			return a, nil
		}

	case TickMsg:
		if a.quitConfirmActive {
			a.quitConfirmActive = false
			a.footerHint = "" // Clear confirmation message
		}

	case ClearTickMsg:
		if a.inputState.ClearConfirming {
			a.inputState.ClearConfirming = false
			a.footerHint = "" // Clear confirmation message
		}

	case OutputRefreshMsg:
		// Force re-render to display updated console output
		// If operation still active, schedule next refresh tick
		if a.asyncOperationActive {
			return a, tea.Tick(100*time.Millisecond, func(t time.Time) tea.Msg {
				return OutputRefreshMsg{}
			})
		}
		// Operation completed, stop sending refresh messages
		return a, nil

	case GitOperationMsg:
		// WORKER THREAD - git operation completed
		return a.handleGitOperation(msg)

	case CacheProgressMsg:
		// Cache building progress update
		return a.handleCacheProgress(msg)

	case CacheRefreshTickMsg:
		// Periodic tick to refresh cache progress UI
		return a.handleCacheRefreshTick()

	case RestoreTimeTravelMsg:
		// Time travel restoration completed (Phase 0)
		return a.handleRestoreTimeTravel(msg)

	case git.TimeTravelCheckoutMsg:
		// Time travel checkout operation completed
		return a.handleTimeTravelCheckout(msg)

	case git.TimeTravelMergeMsg:
		// Time travel merge operation completed
		return a.handleTimeTravelMerge(msg)

	case git.TimeTravelReturnMsg:
		// Time travel return operation completed
		return a.handleTimeTravelReturn(msg)
	case SetupCompleteMsg:
		// SSH key generation completed successfully
		if msg.Step == "generate" {
			a.setupWizardStep = SetupStepDisplayKey
		}
		return a, nil

	case SetupErrorMsg:
		// Error occurred during setup - show error to user
		a.setupWizardError = msg.Error
		a.setupWizardStep = SetupStepError
		return a, nil

	case RewindMsg:
		// WORKER THREAD - rewind operation completed
		return a.handleRewind(msg)

	case RemoteFetchMsg:
		// Background fetch completed - refresh state to update timeline
		if msg.Success {
			if newState, err := git.DetectState(); err == nil {
				a.gitState = newState
				// Only regenerate menu if we're in ModeMenu (don't interfere with other modes)
				if a.mode == ModeMenu {
					a.menuItems = a.GenerateMenu()
					a.rebuildMenuShortcuts(ModeMenu)
					a.updateFooterHintFromMenu()
				}
			}
		}
		return a, nil

	case AutoUpdateTickMsg:
		// Periodic auto-update tick
		return a.handleAutoUpdateTick()

	case AutoUpdateAnimationMsg:
		// Auto-update spinner animation frame
		return a.handleAutoUpdateAnimation()

	case AutoUpdateCompleteMsg:
		// Background state detection completed
		return a.handleAutoUpdateComplete(msg.State)

	}

	return a, nil
}

// View renders the current view
func (a *Application) View() string {
	var contentText string

	// Render based on current mode
	switch a.mode {
	case ModeMenu:
		contentText = ui.RenderMenuWithBanner(a.sizing, a.menuItemsToMaps(a.menuItems), a.selectedIndex, a.theme)

	case ModeConsole, ModeClone:
		// Console output (full-screen mode, footer handled by GetFooterContent)
		contentText = ui.RenderConsoleOutputFullScreen(
			&a.consoleState,
			a.outputBuffer,
			a.theme,
			a.sizing.TerminalWidth,
			a.sizing.TerminalHeight,
			a.asyncOperationActive && !a.asyncOperationAborted,
			a.asyncOperationAborted,
			a.consoleAutoScroll,
		)

	case ModeConfirmation:
		// Confirmation dialog (centered in content area)
		if a.confirmationDialog != nil {
			contentText = a.confirmationDialog.Render(a.sizing.ContentHeight)
		} else {
			// Fallback if no dialog - return to menu
			a.mode = ModeMenu
			contentText = ui.RenderMenuWithHeight(a.menuItemsToMaps(a.menuItems), a.selectedIndex, a.theme, a.sizing.ContentHeight, a.sizing.ContentInnerWidth)
		}

	case ModeSelectBranch:
		// Dynamic menu from cloneBranches
		items := make([]map[string]interface{}, len(a.cloneBranches))
		for i, branch := range a.cloneBranches {
			items[i] = map[string]interface{}{
				"ID":        branch,
				"Shortcut":  "",
				"Emoji":     "ðŸŒ¿",
				"Label":     branch,
				"Hint":      fmt.Sprintf("Set %s as canon branch", branch),
				"Enabled":   true,
				"Separator": false,
			}
		}
		contentText = ui.RenderMenuWithHeight(items, a.selectedIndex, a.theme, a.sizing.ContentHeight, a.sizing.ContentInnerWidth)
	case ModeInput:
