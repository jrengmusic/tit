	case ModeCloneURL:
		textInputState := ui.TextInputState{
			Value:     a.inputValue,
			CursorPos: a.inputCursorPosition,
			Height:    a.inputHeight,
		}

		footer := a.GetFooterContent()
		return ui.RenderTextInputFullScreen(
			a.sizing,
			a.theme,
			a.inputPrompt,
			textInputState,
			footer,
		)
	case ModeCloneLocation:
		contentText = ui.RenderMenuWithHeight(a.menuItemsToMaps(a.menuCloneLocation()), a.selectedIndex, a.theme, a.sizing.ContentHeight, a.sizing.ContentInnerWidth)
	case ModeInitializeLocation:
		contentText = ui.RenderMenuWithHeight(a.menuItemsToMaps(a.menuInitializeLocation()), a.selectedIndex, a.theme, a.sizing.ContentHeight, a.sizing.ContentInnerWidth)

	case ModeHistory:
		// Render history split-pane view (footer handled by GetFooterContent)
		if a.historyState == nil {
			contentText = "History state not initialized"
		} else {
			contentText = ui.RenderHistorySplitPane(
				a.historyState,
				a.theme,
				a.sizing.TerminalWidth,
				a.sizing.TerminalHeight,
			)
		}
	case ModeFileHistory:
		// Render file(s) history split-pane view (footer handled by GetFooterContent)
		if a.fileHistoryState == nil {
			contentText = "File history state not initialized"
		} else {
			contentText = ui.RenderFileHistorySplitPane(
				a.fileHistoryState,
				a.theme,
				a.sizing.TerminalWidth,
				a.sizing.TerminalHeight,
			)
		}
	case ModeConflictResolve:
		// Render conflict resolution UI using generic N-column view (footer handled by GetFooterContent)
		if a.conflictResolveState == nil {
			contentText = "No conflict state initialized"
		} else {
			contentText = ui.RenderConflictResolveGeneric(
				a.conflictResolveState.Files,
				a.conflictResolveState.SelectedFileIndex,
				a.conflictResolveState.FocusedPane,
				a.conflictResolveState.NumColumns,
				a.conflictResolveState.ColumnLabels,
				a.conflictResolveState.ScrollOffsets,
				a.conflictResolveState.LineCursors,
				a.width,
				a.height,
				a.theme,
			)
		}
	case ModeSetupWizard:
		// Email step uses same full-screen input as ModeInput
		if a.setupWizardStep == SetupStepEmail {
			return a.renderSetupEmail()
		}
		// Other setup wizard steps
		contentText = a.renderSetupWizard()

	case ModeConfig:
		contentText = ui.RenderMenuWithBanner(a.sizing, a.menuItemsToMaps(a.menuItems), a.selectedIndex, a.theme)

	case ModeBranchPicker:
		if a.branchPickerState == nil {
			// Initialize branch picker state if not yet created
			a.branchPickerState = &ui.BranchPickerState{
				Branches:          []ui.BranchInfo{},
				SelectedIdx:       0,
				PaneFocused:       true,
				ListScrollOffset:  0,
				DetailsLineCursor: 0,
				DetailsScrollOff:  0,
			}
		}
		// Render using SSOT (ListPane + TextPane) matching history pattern
		contentText = ui.RenderBranchPickerSplitPane(a.branchPickerState, a.theme, a.sizing.TerminalWidth, a.sizing.TerminalHeight)

	case ModePreferences:
		// All menus work the same SSOT way - generate items when needed
		if len(a.menuItems) == 0 {
			a.menuItems = a.GeneratePreferencesMenu()
		}
		// Render preferences with banner (reads values directly from config)
		contentText = ui.RenderPreferencesWithBanner(a.appConfig, a.selectedIndex, a.theme, a.sizing)

	default:
		panic(fmt.Sprintf("Unknown app mode: %v", a.mode))
	}

	// Full-screen modes: skip header, show footer only
	if a.mode == ModeConsole || a.mode == ModeClone || a.mode == ModeFileHistory || a.mode == ModeHistory || a.mode == ModeConflictResolve || a.mode == ModeBranchPicker {
		footer := a.GetFooterContent()
		return contentText + "\n" + footer
	}

	// Render header using state header (or placeholder)
	header := a.RenderStateHeader()

	// Render footer content using unified footer system
	footer := a.GetFooterContent()

	// Use reactive layout
	return ui.RenderReactiveLayout(a.sizing, a.theme, header, contentText, footer)
}

// Init initializes the application
func (a *Application) Init() tea.Cmd {
	// sizing is already set from NewApplication with default dimensions (80, 40)
	// WindowSizeMsg will update it to actual terminal dimensions
	// Config is already loaded in main.go and passed to NewApplication (fail-fast)

	// CONTRACT: Start cache building immediately on app startup
	// Cache MUST be ready before history menus can be used
	commands := []tea.Cmd{tea.EnableBracketedPaste}

	if a.cacheLoadingStarted {
		commands = append(commands,
			a.cmdPreloadHistoryMetadata(),
			a.cmdPreloadFileHistoryDiffs(),
		)
	}

	// Async fetch remote on startup to ensure timeline accuracy
	// Without this, timeline state uses stale local refs
	// CONTRACT: Only start timeline sync if HasRemote AND AutoUpdate.Enabled
	// Fetch remote if available
	if a.gitState != nil && a.gitState.Remote == git.HasRemote {
		commands = append(commands, cmdFetchRemote())
	}

	// Start auto-update (Phase 2)
	if cmd := a.startAutoUpdate(); cmd != nil {
		commands = append(commands, cmd)
	}

	return tea.Batch(commands...)
}

// GetFooterHint returns the footer hint text
func (a *Application) GetFooterHint() string {
	return a.footerHint
}

// handleCacheProgress handles cache building progress updates
func (a *Application) handleCacheProgress(msg CacheProgressMsg) (tea.Model, tea.Cmd) {
	// Cache progress received - regenerate menu to show updated progress
	// Menu generator will read progress fields and show disabled state with progress

	// Only regenerate menu if we're in ModeMenu (don't interfere with other modes)
	if a.mode == ModeMenu {
		menu := a.GenerateMenu()
		a.menuItems = menu
		if !a.quitConfirmActive && len(menu) > 0 && a.selectedIndex < len(menu) {
			a.footerHint = menu[a.selectedIndex].Hint
		}
	}

	if msg.Complete {
		// Cache complete - rebuild menu shortcuts to enable items (only in ModeMenu)
		if a.mode == ModeMenu {
			a.rebuildMenuShortcuts(ModeMenu)
		}

		// Check if BOTH caches are now complete (for time travel success message)
		a.historyCacheMutex.Lock()
		metadataReady := a.cacheMetadata
		a.historyCacheMutex.Unlock()

		a.diffCacheMutex.Lock()
		diffsReady := a.cacheDiffs
		a.diffCacheMutex.Unlock()

		// If both caches complete AND in console mode after async operation finished,
		// show "Press ESC to return to menu" message
		if metadataReady && diffsReady && a.mode == ModeConsole && !a.asyncOperationActive {
			buffer := ui.GetBuffer()

			// Check if this is time travel mode (handled separately)
			if a.gitState != nil && a.gitState.Operation == git.TimeTraveling {
				buffer.Append(ConsoleMessages["time_travel_success"], ui.TypeStatus)
			} else {
				// Regular operation (commit, push, etc.) - show completion message
				buffer.Append(GetFooterMessageText(MessageOperationComplete), ui.TypeInfo)
			}
		}
	}

	return a, nil
}

// handleCacheRefreshTick handles periodic cache progress refresh
// Regenerates menu to show updated progress and re-schedules if caches not complete
func (a *Application) handleCacheRefreshTick() (tea.Model, tea.Cmd) {
	// Check if both caches are complete
	a.historyCacheMutex.Lock()
	metadataComplete := a.cacheMetadata
	a.historyCacheMutex.Unlock()

	a.diffCacheMutex.Lock()
	diffsComplete := a.cacheDiffs
	a.diffCacheMutex.Unlock()

	// If both complete, stop ticking
	if metadataComplete && diffsComplete {
		return a, nil
	}

	// Advance animation frame
	a.cacheAnimationFrame++

	// Only regenerate menu if we're in ModeMenu (don't interfere with other modes)
	if a.mode == ModeMenu {
		menu := a.GenerateMenu()
		a.menuItems = menu
		if !a.quitConfirmActive && len(menu) > 0 && a.selectedIndex < len(menu) {
			a.footerHint = menu[a.selectedIndex].Hint
		}
	}

	// Re-schedule another tick
	return a, a.cmdRefreshCacheProgress()
}

// updateFooterHintFromMenu updates footer with hint of currently selected menu item
// Skips update if app-level message is active (quitConfirmActive)
func (a *Application) updateFooterHintFromMenu() {
	if a.quitConfirmActive {
		return
	}
	if a.selectedIndex >= 0 && a.selectedIndex < len(a.menuItems) {
		if !a.menuItems[a.selectedIndex].Separator {
			a.footerHint = a.menuItems[a.selectedIndex].Hint
		}
	}
}

// GetGitState returns the current git state
func (a *Application) GetGitState() interface{} {
	return a.gitState
}

// RenderStateHeader renders the full git state header (5 rows) using lipgloss
// Row 1: CWD (left) | OPERATION (right)
// RenderStateHeader renders the state header per REACTIVE-LAYOUT-PLAN.md
// 2-column layout: 80/20 split
// LEFT (80%): CWD, Remote, WorkingTree, Timeline
// RIGHT (20%): Operation, Branch
func (a *Application) RenderStateHeader() string {
	state := a.gitState

	if state == nil || state.Operation == git.NotRepo {
		return ""
	}

	cwd, _ := os.Getwd()

	remoteURL := "ðŸ”Œ NO REMOTE"
	remoteColor := a.theme.DimmedTextColor
	if state.Remote == git.HasRemote {
		url := git.GetRemoteURL()
		if url != "" {
			remoteURL = "ðŸ”— " + url
			remoteColor = a.theme.AccentTextColor
		}
	}

	wtInfo := a.workingTreeInfo[state.WorkingTree]
	wtDesc := []string{wtInfo.Description(state.CommitsAhead, state.CommitsBehind)}

	timelineEmoji := "ðŸ”Œ"
	timelineLabel := "N/A"
	timelineColor := a.theme.DimmedTextColor
	timelineDesc := []string{"No remote configured."}

	if state.Operation == git.TimeTraveling {
		if a.timeTravelInfo != nil {
			shortHash := a.timeTravelInfo.CurrentCommit.Hash
			if len(shortHash) >= 7 {
				shortHash = shortHash[:7]
			}
			timelineEmoji = "ðŸ“Œ"
			timelineLabel = "DETACHED @ " + shortHash
			timelineColor = a.theme.OutputWarningColor
			timelineDesc = []string{"Viewing commit from " + a.timeTravelInfo.CurrentCommit.Time.Format("Jan 2, 2006")}
		}
	} else if state.Timeline != "" {
		tlInfo := a.timelineInfo[state.Timeline]
		timelineEmoji = tlInfo.Emoji
		timelineLabel = tlInfo.Label
		timelineColor = tlInfo.Color
		timelineDesc = []string{tlInfo.Description(state.CommitsAhead, state.CommitsBehind)}
	}

	// Operation status (right column top)
	opInfo := a.operationInfo[state.Operation]

	// Branch name (right column bottom)
	branchName := state.CurrentBranch
	if branchName == "" {
		branchName = "N/A"
	}

	headerState := ui.HeaderState{
		CurrentDirectory: cwd,
		RemoteURL:        remoteURL,
		RemoteColor:      remoteColor,
		OperationEmoji:   opInfo.Emoji,
		OperationLabel:   opInfo.Label,
		OperationColor:   opInfo.Color,
		BranchEmoji:      "ðŸŒ¿",
		BranchLabel:      branchName,
		BranchColor:      a.theme.AccentTextColor,
		WorkingTreeEmoji: wtInfo.Emoji,
		WorkingTreeLabel: wtInfo.Label,
		WorkingTreeDesc:  wtDesc,
		WorkingTreeColor: wtInfo.Color,
		TimelineEmoji:    timelineEmoji,
		TimelineLabel:    timelineLabel,
		TimelineDesc:     timelineDesc,
		TimelineColor:    timelineColor,
		SyncInProgress:   a.autoUpdateInProgress,
		SyncFrame:        a.autoUpdateFrame,
	}

	info := ui.RenderHeaderInfo(a.sizing, a.theme, headerState)

	return ui.RenderHeader(a.sizing, a.theme, info)
}

// isInputMode checks if current mode accepts text input
func (a *Application) isInputMode() bool {
	return a.mode == ModeInput ||
		a.mode == ModeCloneURL ||
		(a.mode == ModeSetupWizard && a.setupWizardStep == SetupStepEmail)
}

// menuItemsToMaps converts MenuItem slice to map slice for rendering
// Note: Hint is excluded from maps (displayed in footer instead)
func (a *Application) menuItemsToMaps(items []MenuItem) []map[string]interface{} {
	maps := make([]map[string]interface{}, len(items))
	for i, item := range items {
		maps[i] = map[string]interface{}{
			"ID":        item.ID,
			"Shortcut":  item.Shortcut,
			"Emoji":     item.Emoji,
			"Label":     item.Label,
			"Enabled":   item.Enabled,
			"Separator": item.Separator,
		}
	}
	return maps
}

// buildKeyHandlers builds the complete handler registry for all modes
// Global handlers take priority and are merged into each mode
func (a *Application) buildKeyHandlers() map[AppMode]map[string]KeyHandler {
	// Global handlers - highest priority, applied to all modes
	globalHandlers := map[string]KeyHandler{
		"ctrl+c": a.handleKeyCtrlC,
		"q":      a.handleKeyCtrlC,
		"esc":    a.handleKeyESC,
		"/":      a.handleKeySlash, // Open config menu
		"ctrl+v": a.handleKeyPaste, // Linux/Windows/macOS
		"cmd+v":  a.handleKeyPaste, // macOS cmd+v
		"meta+v": a.handleKeyPaste, // macOS meta (cmd) - Bubble Tea may send this
		"alt+v":  a.handleKeyPaste, // Fallback
	}

	cursorNavMixin := CursorNavigationMixin{}

	// Generic input cursor handlers for single-field inputs
	genericInputNav := cursorNavMixin.CreateHandlers(
		func(a *Application) string { return a.inputValue },
		func(a *Application) int { return a.inputCursorPosition },
		func(a *Application, pos int) { a.inputCursorPosition = pos },
	)

	// Mode-specific handlers (global merged in after)
	modeHandlers := map[AppMode]map[string]KeyHandler{
		ModeMenu: NewModeHandlers().
			WithMenuNav(a).
			On("enter", a.handleMenuEnter).
			Build(),
		ModeConsole: NewModeHandlers().
			On("up", a.handleConsoleUp).
			On("k", a.handleConsoleUp).
			On("down", a.handleConsoleDown).
			On("j", a.handleConsoleDown).
			On("pageup", a.handleConsolePageUp).
			On("pagedown", a.handleConsolePageDown).
			Build(),
		ModeInput: NewModeHandlers().
			WithCursorNav(genericInputNav).
			On("enter", a.handleInputSubmit).
			Build(),
		ModeInitializeLocation: NewModeHandlers().
			WithMenuNav(a).
			On("enter", a.handleInitLocationSelection).
			On("1", a.handleInitLocationChoice1).
			On("2", a.handleInitLocationChoice2).
			Build(),
		ModeCloneURL: NewModeHandlers().
			WithCursorNav(genericInputNav).
			On("enter", a.handleCloneURLSubmit).
			Build(),
		ModeCloneLocation: NewModeHandlers().
			WithMenuNav(a).
			On("enter", a.handleCloneLocationSelection).
			On("1", a.handleCloneLocationChoice1).
			On("2", a.handleCloneLocationChoice2).
			Build(),
		ModeConfirmation: NewModeHandlers().
			On("left", a.handleConfirmationLeft).
			On("right", a.handleConfirmationRight).
			On("h", a.handleConfirmationLeft).
			On("l", a.handleConfirmationRight).
			On("y", a.handleConfirmationYes).
			On("n", a.handleConfirmationNo).
			On("enter", a.handleConfirmationEnter).
			Build(),
		ModeHistory: NewModeHandlers().
			On("up", a.handleHistoryUp).
			On("k", a.handleHistoryUp).
			On("down", a.handleHistoryDown).
			On("j", a.handleHistoryDown).
			On("tab", a.handleHistoryTab).
			On("enter", a.handleHistoryEnter).
			On("ctrl+r", a.handleHistoryRewind).
			On("esc", a.handleHistoryEsc).
			Build(),
		ModeFileHistory: NewModeHandlers().
			On("up", a.handleFileHistoryUp).
			On("down", a.handleFileHistoryDown).
			On("k", a.handleFileHistoryUp).
			On("j", a.handleFileHistoryDown).
			On("tab", a.handleFileHistoryTab).
			On("y", a.handleFileHistoryCopy).
			On("v", a.handleFileHistoryVisualMode).
			On("esc", a.handleFileHistoryEsc).
			Build(),
		ModeConflictResolve: NewModeHandlers().
			On("up", a.handleConflictUp).
			On("k", a.handleConflictUp).
			On("down", a.handleConflictDown).
			On("j", a.handleConflictDown).
			On("tab", a.handleConflictTab).
			On(" ", a.handleConflictSpace). // Space character, not "space"
			On("enter", a.handleConflictEnter).
			Build(),
		ModeClone: NewModeHandlers().
			On("up", a.handleConsoleUp).
			On("k", a.handleConsoleUp).
			On("down", a.handleConsoleDown).
			On("j", a.handleConsoleDown).
			On("pageup", a.handleConsolePageUp).
			On("pagedown", a.handleConsolePageDown).
			Build(),
		ModeSelectBranch: NewModeHandlers().
			WithMenuNav(a).
			On("enter", a.handleSelectBranchEnter).
			Build(),
		ModeSetupWizard: NewModeHandlers().
			On("enter", a.handleSetupWizardEnter).
			Build(),
		ModeConfig: NewModeHandlers().
			WithMenuNav(a).
			On("enter", a.handleConfigMenuEnter).
			Build(),
		ModeBranchPicker: NewModeHandlers().
			On("up", a.handleBranchPickerUp).
			On("k", a.handleBranchPickerUp).
			On("down", a.handleBranchPickerDown).
			On("j", a.handleBranchPickerDown).
			On("enter", a.handleBranchPickerEnter).
			Build(),
		ModePreferences: NewModeHandlers().
			WithMenuNav(a).
			On("enter", a.handlePreferencesEnter).
			On(" ", a.handlePreferencesEnter).
			On("=", a.handlePreferencesIncrement).
			On("-", a.handlePreferencesDecrement).
			On("+", a.handlePreferencesIncrement10).
			On("_", a.handlePreferencesDecrement10).
			Build(),
	}

	// Merge global handlers into each mode (global takes priority)
	for mode := range modeHandlers {
		for key, handler := range globalHandlers {
			modeHandlers[mode][key] = handler
		}
	}

	return modeHandlers
}

// rebuildMenuShortcuts dynamically registers keyboard handlers for all current menu item shortcuts
// Called after GenerateMenu() to ensure shortcuts match current git state
func (a *Application) rebuildMenuShortcuts(mode AppMode) {
	if a.keyHandlers[mode] == nil {
		a.keyHandlers[mode] = make(map[string]KeyHandler)
	}

	// Remove old shortcut handlers (keep navigation and enter)
	// We'll rebuild from scratch by first copying base handlers
	var baseHandlers map[string]KeyHandler
	if mode == ModeMenu {
		baseHandlers = NewModeHandlers().
			WithMenuNav(a).
			On("enter", a.handleMenuEnter).
			On(" ", a.handleMenuEnter). // Space as enter alias
			Build()
	} else if mode == ModeConfig {
		baseHandlers = NewModeHandlers().
			WithMenuNav(a).
			On("enter", a.handleConfigMenuEnter).
			On(" ", a.handleConfigMenuEnter). // Space as enter alias
			Build()
	} else if mode == ModePreferences {
		baseHandlers = NewModeHandlers().
			WithMenuNav(a).
			On("enter", a.handlePreferencesEnter).
			On(" ", a.handlePreferencesEnter). // Space as enter alias
			On("=", a.handlePreferencesIncrement).
			On("-", a.handlePreferencesDecrement).
			On("+", a.handlePreferencesIncrement10).
			On("_", a.handlePreferencesDecrement10).
			Build()
	}

	// Start fresh
	newHandlers := make(map[string]KeyHandler)

	// Copy base handlers
	for key, handler := range baseHandlers {
		newHandlers[key] = handler
	}

	// Merge global handlers
	globalHandlers := map[string]KeyHandler{
		"ctrl+c": a.handleKeyCtrlC,
		"q":      a.handleKeyCtrlC,
		"esc":    a.handleKeyESC,
		"/":      a.handleKeySlash, // Open config menu
		"ctrl+v": a.handleKeyPaste,
		"cmd+v":  a.handleKeyPaste,
		"meta+v": a.handleKeyPaste,
		"alt+v":  a.handleKeyPaste,
	}

	// Add global handlers (base handlers take priority, no overrides)
	for key, handler := range globalHandlers {
		if _, exists := baseHandlers[key]; !exists {
			newHandlers[key] = handler
		}
	}

	// Dynamically register shortcuts for current menu items
	for i, item := range a.menuItems {
		if item.Shortcut != "" && item.Enabled && !item.Separator {
			// Capture loop variables in closure
			itemIndex := i
			itemID := item.ID
			itemHint := item.Hint

			// Create handler that selects item and dispatches action
			newHandlers[item.Shortcut] = func(app *Application) (tea.Model, tea.Cmd) {
				app.selectedIndex = itemIndex
				app.footerHint = itemHint
				return app, app.dispatchAction(itemID)
			}
		}
	}

	// Replace handlers for specified mode
	a.keyHandlers[mode] = newHandlers
}

// handleMenuUp moves selection up
func (a *Application) handleMenuUp(app *Application) (tea.Model, tea.Cmd) {
	app.lastMenuActivity = time.Now() // Track menu activity
	if len(app.menuItems) > 0 {
		startIdx := app.selectedIndex
		app.selectedIndex = (app.selectedIndex - 1 + len(app.menuItems)) % len(app.menuItems)
		// Skip separators and disabled items (CONTRACT: disabled items not selectable)
		for app.menuItems[app.selectedIndex].Separator || !app.menuItems[app.selectedIndex].Enabled {
			app.selectedIndex = (app.selectedIndex - 1 + len(app.menuItems)) % len(app.menuItems)
			// Prevent infinite loop if all items disabled
			if app.selectedIndex == startIdx {
				break
			}
		}
		// Update footer hint
		if app.selectedIndex < len(app.menuItems) {
			app.footerHint = app.menuItems[app.selectedIndex].Hint
		}
	}
	return app, nil
}

// handleMenuDown moves selection down
func (a *Application) handleMenuDown(app *Application) (tea.Model, tea.Cmd) {
	app.lastMenuActivity = time.Now() // Track menu activity
	if len(app.menuItems) > 0 {
		startIdx := app.selectedIndex
		app.selectedIndex = (app.selectedIndex + 1) % len(app.menuItems)
		// Skip separators and disabled items (CONTRACT: disabled items not selectable)
		for app.menuItems[app.selectedIndex].Separator || !app.menuItems[app.selectedIndex].Enabled {
			app.selectedIndex = (app.selectedIndex + 1) % len(app.menuItems)
			// Prevent infinite loop if all items disabled
			if app.selectedIndex == startIdx {
				break
			}
		}
		// Update footer hint
		if app.selectedIndex < len(app.menuItems) {
			app.footerHint = app.menuItems[app.selectedIndex].Hint
		}
	}
	return app, nil
}

// handleMenuEnter selects current menu item and dispatches action
func (a *Application) handleMenuEnter(app *Application) (tea.Model, tea.Cmd) {
	app.lastMenuActivity = time.Now() // Track menu activity
	if app.selectedIndex < 0 || app.selectedIndex >= len(app.menuItems) {
		return app, nil
	}
	item := app.menuItems[app.selectedIndex]

	// CONTRACT: Cannot execute separators or disabled items (cache still building)
	if item.Separator || !item.Enabled {
		return app, nil
	}

	// Dispatch action
	return app, app.dispatchAction(item.ID)
}

// Input mode helpers

// insertTextAtCursor inserts text at current cursor position (UTF-8 safe)
func (a *Application) insertTextAtCursor(text string) {
	// Defensive bounds checking
	valueLen := len(a.inputValue)
	if a.inputCursorPosition < 0 {
		a.inputCursorPosition = 0
	}
	if a.inputCursorPosition > valueLen {
		a.inputCursorPosition = valueLen
	}

	// Safe slice operation
	before := a.inputValue[:a.inputCursorPosition]
	after := a.inputValue[a.inputCursorPosition:]
	a.inputValue = before + text + after
	a.inputCursorPosition += len(text)
}

// deleteAtCursor deletes character before cursor (UTF-8 safe)
func (a *Application) deleteAtCursor() {
	valueLen := len(a.inputValue)
	if a.inputCursorPosition <= 0 || valueLen == 0 {
		return
	}
	if a.inputCursorPosition > valueLen {
		a.inputCursorPosition = valueLen
	}

	// Safe slice operation
	before := a.inputValue[:a.inputCursorPosition-1]
	after := a.inputValue[a.inputCursorPosition:]
	a.inputValue = before + after
	a.inputCursorPosition--
}

// updateInputValidation updates validation message for current input
func (a *Application) updateInputValidation() {
	if a.inputAction == "clone_url" {
		currentValue := a.inputValue
		if a.mode == ModeInitializeBranches {
			return // No validation in branch mode
		}
		if currentValue == "" {
			a.inputValidationMsg = ""
		} else if ui.ValidateRemoteURL(currentValue) {
			a.inputValidationMsg = ""
		} else {
			a.inputValidationMsg = "Invalid URL format"
		}
	}
}

// Input mode handlers

// handleInputSubmit handles enter in generic input mode
func (a *Application) handleInputSubmit(app *Application) (tea.Model, tea.Cmd) {
	// UI THREAD - Route input submission based on action type
	switch app.inputAction {
	case "init_branch_name":
		return app.handleInitBranchNameSubmit()
	case "init_subdir_name":
		return app.handleInputSubmitSubdirName(app)
	case "add_remote_url":
		return app.handleAddRemoteSubmit(app)
	case "commit_message":
		return app.handleCommitSubmit(app)
	case "commit_push_message":
		return app.handleCommitPushSubmit(app)
	default:
		return app, nil
	}
}

// handleHistoryRewind handles Ctrl+ENTER in history browser to initiate rewind
func (a *Application) handleHistoryRewind(app *Application) (tea.Model, tea.Cmd) {
	if app.historyState == nil || len(app.historyState.Commits) == 0 {
		return app, nil
	}

	if app.historyState.SelectedIdx < 0 || app.historyState.SelectedIdx >= len(app.historyState.Commits) {
		return app, nil
	}

	selectedCommit := app.historyState.Commits[app.historyState.SelectedIdx]
	app.pendingRewindCommit = selectedCommit.Hash

	return app, app.showRewindConfirmation(selectedCommit.Hash)
}
